package br.com.compiladorn.analisadorsintatico;

import java_cup.runtime.*;
import java.util.*;
import java.io.*;
import br.com.compiladorn.analisadorlexico.Token.*;
import br.com.compiladorn.analisadorlexico.LexemaPOJO;

init with {: scanner.init();              :};
scan with {: return scanner.next_token(); :};

parser code {:

    public void report_error(String message, Object info)  {
        System.out.println("Warning - " + message);
    }

    public void report_fatal_error(String message, Object info)  {
        System.out.println("Error - " + message);
        System.exit(-1);
    }

:};



/* Definindo simbolos terminais */

terminal PROGRAM_BEGUIN, PROGRAM_END, ID, OPERADOR_ARITMETICO, NUMEROS_NATURAIS,
         TEXTO, NUMEROS_REIAS, OPERADOR_LOGICO, OPERADOR_RELACIONAL, INICIO_BLOCO,
         FIM_BLOCO, ATRIBUICAO, THEN, IF, FOR, WHILE, COMENTARIO, LINHA, ERROR,
         FIM_COMANDO, BRANCO, EXPOENTE, FIM_LINHA;


/* Definindo simbolos n√£o-terminais */

non terminal program, statements, statement, statement_function;
non terminal decl_variable, decl_call_function, decl_call_params, decl_params, decl_function, decl_if;
non terminal decl_boolean,decl_assignments, decl_assignment;
non terminal params_type, data_types;


/* Definindo preferencia em caso de ambiguidade */

precedence left PLUS, MINUS;
precedence left TIMES, DIVIDE, MOD;

start with program;

/* The grammar */
expr_list ::= expr_list expr_part 
	      | 
              expr_part;

expr_part ::= expr:e 
	      {: System.out.println("= " + e); :} 
              SEMI              
	      ;

expr      ::= expr:e1 PLUS expr:e2    
	      {: RESULT = new Integer(e1.intValue() + e2.intValue()); :} 
	      | 
              expr:e1 MINUS expr:e2    
              {: RESULT = new Integer(e1.intValue() - e2.intValue()); :} 
	      | 
              expr:e1 TIMES expr:e2 
	      {: RESULT = new Integer(e1.intValue() * e2.intValue()); :} 
	      | 
              expr:e1 DIVIDE expr:e2 
	      {: RESULT = new Integer(e1.intValue() / e2.intValue()); :} 
	      | 
              expr:e1 MOD expr:e2 
	      {: RESULT = new Integer(e1.intValue() % e2.intValue()); :} 
	      | 
              NUMBER:n                 
	      {: RESULT = n; :} 
	      | 
              MINUS expr:e             
	      {: RESULT = new Integer(0 - e.intValue()); :} 
	      %prec UMINUS
	      | 
              LPAREN expr:e RPAREN     
	      {: RESULT = e; :} 
	      ;